mcmc_sample_perturbed <- extract(stan_results$stan_sim_perturb)
results_mcmc <- SummarizeMCMCResults(mcmc_sample)
results_mcmc_pert <- SummarizeMCMCResults(mcmc_sample_perturbed)
results_mcmc_pert$method <- "mcmc_perturbed"
results <- rbind(results_vb, results_mcmc)
result_pert <- rbind(results_vb, results_vb_pert, results_mcmc, results_mcmc_pert)
mean_results <-
filter(results, metric == "mean") %>%
dcast(par + component + group ~ method, value.var="val")
ggplot(filter(mean_results, par != "mu_g")) +
geom_point(aes(x=mcmc, y=mfvb, color=par), size=3) +
geom_abline(aes(slope=1, intercept=0))
ggplot(filter(mean_results, par == "tau")) +
geom_point(aes(x=mcmc, y=mfvb, color=par), size=3) +
geom_abline(aes(slope=1, intercept=0))
stan_results$pp
stan_results$pp_perturb
pp
stan_results$mcmc_time
mcmc_sample$tau
mcmc_sample$sigma_y
dim(mcmc_sample$sigma_y)
plot(mcmc_sample$sigma_y[, 1])
plot(mcmc_sample$sigma_y[, 2])
plot(mcmc_sample$sigma_y[, 3])
vp_opt$lambda_n
vp_opt$lambda_n_min
vp_opt$lambda_v
vp_opt$lambda_diag_min
# "reg" for "regression"
vp_reg <- InitializeVariationalParameters(
x, y, y_g, mu_diag_min=1e-5, lambda_diag_min=1e-5, tau_min=1, lambda_n_min=2.5)
mp_reg <- GetMoments(vp_reg)
# Convenient indices
vp_indices <- GetParametersFromVector(vp_reg, as.numeric(1:vp_reg$encoded_size), FALSE)
mp_indices <- GetMomentsFromVector(mp_reg, as.numeric(1:vp_reg$encoded_size))
pp_indices <- GetPriorsFromVector(pp, as.numeric(1:pp$encoded_size))
#########################################
# Fit and LRVB
# vb_fit <- FitVariationalModel(x, y, y_g, vp_reg, pp)
# print(vb_fit$bfgs_time + vb_fit$tr_time)
# first BFGS
mask <- rep(TRUE, vp_reg$encoded_size)
bfgs_opt_fns <- GetOptimFunctions(x, y, y_g, vp_reg, pp, DerivFun=GetElboDerivatives, mask=mask)
theta_init <- GetVectorFromParameters(vp_reg, TRUE)
bounds <- GetVectorBounds(vp_reg, loc_bound=60, info_bound=10, tau_bound=100)
bfgs_time <- Sys.time()
bfgs_result <- optim(theta_init[mask],
bfgs_opt_fns$OptimVal, bfgs_opt_fns$OptimGrad,
method="L-BFGS-B", lower=bounds$theta_lower[mask], upper=bounds$theta_upper[mask],
control=list(fnscale=-1, maxit=1000, trace=0, factr=1e7))
stopifnot(bfgs_result$convergence == 0)
print(bfgs_result$message)
bfgs_time <- Sys.time() - bfgs_time
vp_bfgs <- GetParametersFromVector(vp_reg, bfgs_result$par, TRUE)
bfgs_time <- Sys.time()
bfgs_result <- optim(theta_init[mask],
bfgs_opt_fns$OptimVal, bfgs_opt_fns$OptimGrad,
method="L-BFGS-B", lower=bounds$theta_lower[mask], upper=bounds$theta_upper[mask],
control=list(fnscale=-1, maxit=1000, trace=0, factr=1e6))
bfgs_time <- Sys.time()
bfgs_result <- optim(theta_init[mask],
bfgs_opt_fns$OptimVal, bfgs_opt_fns$OptimGrad,
method="L-BFGS-B", lower=bounds$theta_lower[mask], upper=bounds$theta_upper[mask],
control=list(fnscale=-1, maxit=1000, trace=0, factr=1e8))
stopifnot(bfgs_result$convergence == 0)
print(bfgs_result$message)
bfgs_time <- Sys.time() - bfgs_time
vp_bfgs <- GetParametersFromVector(vp_reg, bfgs_result$par, TRUE)
# then trust region
library(trust)
tr_time <- Sys.time()
trust_fns <- GetTrustRegionELBO(x, y, y_g, vp_bfgs, pp, verbose=TRUE)
trust_result <- trust(trust_fns$TrustFun, trust_fns$theta_init,
rinit=1, rmax=100, minimize=FALSE, blather=TRUE, iterlim=200)
tr_time <- Sys.time() - tr_time
trust_result$converged
trust_result$value
bfgs_time + tr_time
vp_opt <- vb_fit$vp_opt
vp_mom <- GetMoments(vp_opt)
mfvb_cov <- GetCovariance(vp_opt)
lrvb_terms <- GetLRVB(x, y, y_g, vp_opt, pp)
lrvb_cov <- lrvb_terms$lrvb_cov
prior_sens <- GetSensitivity(vp_opt, pp, lrvb_terms$jac, lrvb_terms$elbo_hess)
# Calculate vb perturbed estimates
vp_mom_vec <- GetVectorFromMoments(vp_mom)
mu_info_offdiag_sens <- prior_sens[, pp_indices$mu_info[1, 2]]
vp_mom_vec_pert <- vp_mom_vec + stan_results$perturb_epsilon * mu_info_offdiag_sens
vp_mom_pert <- GetMomentsFromVector(vp_mom, vp_mom_vec_pert)
# Pack the standard deviations into readable forms.
mfvb_sd <- GetMomentsFromVector(vp_mom, sqrt(diag(mfvb_cov)))
lrvb_sd <- GetMomentsFromVector(vp_mom, sqrt(diag(lrvb_cov)))
results_vb <- SummarizeMomentParameters(vp_mom, mfvb_sd, lrvb_sd)
results_vb_pert <- SummarizeMomentParameters(vp_mom_pert, mfvb_sd, lrvb_sd)
results_vb_pert$method <- "mfvb_perturbed"
mcmc_sample <- extract(stan_results$stan_sim)
mcmc_sample_perturbed <- extract(stan_results$stan_sim_perturb)
results_mcmc <- SummarizeMCMCResults(mcmc_sample)
results_mcmc_pert <- SummarizeMCMCResults(mcmc_sample_perturbed)
results_mcmc_pert$method <- "mcmc_perturbed"
results <- rbind(results_vb, results_mcmc)
result_pert <- rbind(results_vb, results_vb_pert, results_mcmc, results_mcmc_pert)
mean_results <-
filter(results, metric == "mean") %>%
dcast(par + component + group ~ method, value.var="val")
ggplot(filter(mean_results, par != "mu_g")) +
geom_point(aes(x=mcmc, y=mfvb, color=par), size=3) +
geom_abline(aes(slope=1, intercept=0))
vp_opt$lambda_n
vp_opt$lambda_n_min
vp_reg <- InitializeVariationalParameters(
x, y, y_g, mu_diag_min=1e-5, lambda_diag_min=1e-5, tau_min=1, lambda_n_min=2.5)
mp_reg <- GetMoments(vp_reg)
# Convenient indices
vp_indices <- GetParametersFromVector(vp_reg, as.numeric(1:vp_reg$encoded_size), FALSE)
mp_indices <- GetMomentsFromVector(mp_reg, as.numeric(1:vp_reg$encoded_size))
pp_indices <- GetPriorsFromVector(pp, as.numeric(1:pp$encoded_size))
#########################################
# Fit and LRVB
library(trust)
# vb_fit <- FitVariationalModel(x, y, y_g, vp_reg, pp)
# print(vb_fit$bfgs_time + vb_fit$tr_time)
# first BFGS
mask <- rep(TRUE, vp_reg$encoded_size)
bfgs_opt_fns <- GetOptimFunctions(x, y, y_g, vp_reg, pp, DerivFun=GetElboDerivatives, mask=mask)
theta_init <- GetVectorFromParameters(vp_reg, TRUE)
bounds <- GetVectorBounds(vp_reg, loc_bound=60, info_bound=10, tau_bound=100)
bfgs_time <- Sys.time()
bfgs_result <- optim(theta_init[mask],
bfgs_opt_fns$OptimVal, bfgs_opt_fns$OptimGrad,
method="L-BFGS-B", lower=bounds$theta_lower[mask], upper=bounds$theta_upper[mask],
control=list(fnscale=-1, maxit=1000, trace=0, factr=1e8))
stopifnot(bfgs_result$convergence == 0)
print(bfgs_result$message)
bfgs_time <- Sys.time() - bfgs_time
vp_bfgs <- GetParametersFromVector(vp_reg, bfgs_result$par, TRUE)
# then trust region
tr_time <- Sys.time()
trust_fns <- GetTrustRegionELBO(x, y, y_g, vp_bfgs, pp, verbose=TRUE)
trust_result <- trust(trust_fns$TrustFun, trust_fns$theta_init,
rinit=1, rmax=1e6, minimize=FALSE, blather=TRUE, iterlim=200)
tr_time <- Sys.time() - tr_time
trust_result$converged
trust_result$value
bfgs_time + tr_time
vp_opt <- GetParametersFromVector(vp_reg, trust_result$argument, TRUE)
vp_opt$lambda_n
vp_opt$lambda_n_min
vp_opt$tau
vp_opt <- vb_fit$vp_opt
vp_mom <- GetMoments(vp_opt)
mfvb_cov <- GetCovariance(vp_opt)
lrvb_terms <- GetLRVB(x, y, y_g, vp_opt, pp)
lrvb_cov <- lrvb_terms$lrvb_cov
prior_sens <- GetSensitivity(vp_opt, pp, lrvb_terms$jac, lrvb_terms$elbo_hess)
# Calculate vb perturbed estimates
vp_mom_vec <- GetVectorFromMoments(vp_mom)
mu_info_offdiag_sens <- prior_sens[, pp_indices$mu_info[1, 2]]
vp_mom_vec_pert <- vp_mom_vec + stan_results$perturb_epsilon * mu_info_offdiag_sens
vp_mom_pert <- GetMomentsFromVector(vp_mom, vp_mom_vec_pert)
###########################
# Sumamrize results
# Pack the standard deviations into readable forms.
mfvb_sd <- GetMomentsFromVector(vp_mom, sqrt(diag(mfvb_cov)))
lrvb_sd <- GetMomentsFromVector(vp_mom, sqrt(diag(lrvb_cov)))
results_vb <- SummarizeMomentParameters(vp_mom, mfvb_sd, lrvb_sd)
results_vb_pert <- SummarizeMomentParameters(vp_mom_pert, mfvb_sd, lrvb_sd)
results_vb_pert$method <- "mfvb_perturbed"
mcmc_sample <- extract(stan_results$stan_sim)
mcmc_sample_perturbed <- extract(stan_results$stan_sim_perturb)
results_mcmc <- SummarizeMCMCResults(mcmc_sample)
results_mcmc_pert <- SummarizeMCMCResults(mcmc_sample_perturbed)
results_mcmc_pert$method <- "mcmc_perturbed"
results <- rbind(results_vb, results_mcmc)
result_pert <- rbind(results_vb, results_vb_pert, results_mcmc, results_mcmc_pert)
stop("Graphs follow -- not executing.")
mean_results <-
filter(results, metric == "mean") %>%
dcast(par + component + group ~ method, value.var="val")
ggplot(filter(mean_results, par != "mu_g")) +
geom_point(aes(x=mcmc, y=mfvb, color=par), size=3) +
geom_abline(aes(slope=1, intercept=0))
ggplot(filter(mean_results, par != "mu_g")) +
geom_point(aes(x=mcmc, y=mfvb, color=par), size=3) +
geom_abline(aes(slope=1, intercept=0))
ggplot(filter(mean_results, par == "mu_g")) +
geom_point(aes(x=mcmc, y=mfvb, color=par), size=3) +
geom_abline(aes(slope=1, intercept=0))
ggplot(filter(mean_results, par == "tau")) +
geom_point(aes(x=mcmc, y=mfvb, color=par), size=3) +
geom_abline(aes(slope=1, intercept=0))
sd_results <-
filter(results, metric == "sd") %>%
dcast(par + component + group ~ method, value.var="val")
ggplot(filter(sd_results, par != "mu_g")) +
geom_point(aes(x=mcmc, y=mfvb, shape=par, color="mfvb"), size=3) +
geom_point(aes(x=mcmc, y=lrvb, shape=par, color="lrvb"), size=3) +
geom_abline(aes(slope=1, intercept=0))
ggplot(filter(sd_results, par == "mu_g")) +
geom_point(aes(x=mcmc, y=mfvb, shape=par, color="mfvb"), size=3) +
geom_point(aes(x=mcmc, y=lrvb, shape=par, color="lrvb"), size=3) +
geom_abline(aes(slope=1, intercept=0))
mean_pert_results <-
filter(result_pert, metric == "mean") %>%
dcast(par + component + group ~ method, value.var="val") %>%
mutate(mfvb_diff = mfvb_perturbed - mfvb, mcmc_diff = mcmc_perturbed - mcmc)
ggplot(filter(mean_pert_results, par != "mu_g")) +
geom_point(aes(x=mcmc_diff, y=mfvb_diff, color=par), size=3) +
geom_abline(aes(slope=1, intercept=0))
ggplot(filter(mean_pert_results, par == "mu_g")) +
geom_point(aes(x=mcmc_diff, y=mfvb_diff, color=par), size=3) +
geom_abline(aes(slope=1, intercept=0))
bfgs_time + tr_time
(bfgs_time + tr_time) / 60
bfgs_time + tr_time
nlm
?nlm
attr(v)
v <- 5
attr(v)
?attr
attributes(v)
attributes(v) <- list(yes="ok", no="nope")
attributes(v)
attr(v, "yes")
v$yes
foo <- array(1:20, 2, 2, 5)
?array
foo <- array(1:20, dim=c(2, 2, 5))
foo
attributes(foo)
className(foo)
typeof(foo)
dim(foo)
dim
?nlm
trust_fns
nlm_fns <- GetTrustRegionELBO(x, y, y_g, vp_bfgs, pp, verbose=TRUE)
ret <- nlm_fns$TrustFun(theta)
nlm_fns <- GetTrustRegionELBO(x, y, y_g, vp_bfgs, pp, verbose=TRUE)
NLMFunc <- function(theta) {
ret <- nlm_fns$TrustFun(theta)
val <- ret$value
attributes(val)  <- list(gradient=ret$gradient, hessian=ret$hessian)
return(val)
}
?nlm
nlm(NLMFunc, bfgs_result$par, print.level=2)
?nlm
# Or nlm
nlm_fns <- GetTrustRegionELBO(x, y, y_g, vp_bfgs, pp, verbose=TRUE)
NLMFunc <- function(theta) {
ret <- nlm_fns$TrustFun(theta)
val <- -1 * ret$value
attributes(val)  <- list(gradient=-1 * ret$gradient, hessian=-1 * ret$hessian)
return(val)
}
nlm(NLMFunc, bfgs_result$par, print.level=2)
theta <- bfgs_result$par
ret <- nlm_fns$TrustFun(theta)
val <- -1 * ret$value
val
-1 * ret$hessian
ret$gradient
bfgs_result$value
val
nlm(NLMFunc, bfgs_result$par, print.level=2, fscale=-0.5 * bfgs_result$value)
NLMFunc <- function(theta) {
#   ret <- nlm_fns$TrustFun(theta)
#   val <- -1 * ret$value
#   attributes(val)  <- list(gradient=-1 * ret$gradient, hessian=-1 * ret$hessian)
val <- -1 * bfgs_opt_fns$OptimVal(theta)
grad <- -1 * bfgs_opt_fns$OptimGrad(theta)
attributes(val)  <- list(gradient=grad)
return(val)
}
nlm(NLMFunc, bfgs_result$par, print.level=2, fscale=-0.5 * bfgs_result$value)
bfgs_result$value
nlm(NLMFunc, bfgs_result$par, print.level=1, fscale=-0.5 * bfgs_result$value)
nlm_result <- nlm(NLMFunc, theta_init, print.level=1, fscale=-0.5 * bfgs_result$value)
nlm_result <- nlm(NLMFunc, bfgs_result$par, print.level=1, fscale=-0.5 * bfgs_result$value)
nlm_result$minimum
nlm_result$estimate
vp_nlm <- GetParametersFromVector(vp_reg, nlm_result$estimate, TRUE)
NLMFunc <- function(theta) {
val <- -1 * bfgs_opt_fns$OptimVal(theta)
grad <- -1 * bfgs_opt_fns$OptimGrad(theta)
attributes(val)  <- list(gradient=grad)
return(val)
}
nlm_result <- nlm(NLMFunc, bfgs_result$par, print.level=1, fscale=-0.5 * bfgs_result$value)
vp_nlm <- GetParametersFromVector(vp_reg, nlm_result$estimate, TRUE)
# Finish with trust region
tr_time <- Sys.time()
trust_fns <- GetTrustRegionELBO(x, y, y_g, vp_nlm, pp, verbose=TRUE)
trust_result <- trust(trust_fns$TrustFun, trust_fns$theta_init,
rinit=1, rmax=1e6, minimize=FALSE, blather=TRUE, iterlim=200)
tr_time <- Sys.time() - tr_time
trust_result$converged
trust_result$value
bfgs_time + tr_time + nlm_time
nlm_time <- Sys.time()
NLMFunc <- function(theta) {
val <- -1 * bfgs_opt_fns$OptimVal(theta)
grad <- -1 * bfgs_opt_fns$OptimGrad(theta)
attributes(val)  <- list(gradient=grad)
return(val)
}
nlm_result <- nlm(NLMFunc, bfgs_result$par, print.level=1, fscale=-0.5 * bfgs_result$value)
vp_nlm <- GetParametersFromVector(vp_reg, nlm_result$estimate, TRUE)
nlm_time <- Sys.time() - nlm_time
bfgs_time + tr_time + nlm_time
nlm_result <- nlm(NLMFunc, bfgs_result$par, print.level=1, fscale=-0.5 * bfgs_result$value)
nlm_result <- nlm(NLMFunc, nlm_result$estimate, print.level=1, fscale=-0.5 * bfgs_result$value)
trust_result
plot(trust_result$valpath)
tr_steps <- trust_result$argpath
dim(tr_steps)
trust_result$iterations
length(theta_init)
step_dist <-dist(tr_steps)
step_dist
step_mds <- cmdscale(step_dist, eig=TRUE, k=2)
step_mds
mds <- data.frame(step_mds$points)
mds
ggplot(mds,aes(x=X1, y=X2)) +
geom_line() +
geom_point()
ggplot(mds,aes(x=X1, y=X2)) + geom_line() + geom_point()
trust_result$valpath
ggplot(mds,aes(x=X1, y=X2, z=trust_result$valpath)) + geom_line() + geom_point()
ggplot(mds,aes(x=X1, y=X2, z=color$valpath)) + geom_line() + geom_point()
ggplot(mds,aes(x=X1, y=X2, color=trust_result$valpath)) + geom_line() + geom_point()
step_mds <- cmdscale(step_dist, eig=TRUE, k=4)
mds <- data.frame(step_mds$points)
ggplot(mds,aes(x=X1, y=X2, color=trust_result$valpath)) + geom_line() + geom_point()
ggplot(mds,aes(x=X1, y=X3, color=trust_result$valpath)) + geom_line() + geom_point()
ggplot(mds,aes(x=X1, y=X4, color=trust_result$valpath)) + geom_line() + geom_point()
ggplot(mds,aes(x=X2, y=X4, color=trust_result$valpath)) + geom_line() + geom_point()
ggplot(mds,aes(x=X2, y=X3, color=trust_result$valpath)) + geom_line() + geom_point()
mds$val <- trust_result$valpath
ggplot(mds,aes(x=X2, y=X3, color=val)) + geom_line() + geom_point()
ggplot(mds, aes(x=X1, y=X2, z = z)) + stat_contour()
ggplot(mds, aes(x=X1, y=X2, z=val)) + stat_contour()
mds
volcano3d <- melt(volcano)
volcano3d
head(volcano3d)
head(volcano)
ggplot(mds,aes(x=X2, y=X3, color=val)) + geom_line() + geom_point()
ggplot(mds,aes(x=X1, y=X2, color=val)) + geom_line() + geom_point()
ggplot(mds,aes(x=X1, y=X3, color=val)) + geom_line() + geom_point()
ggplot(mds,aes(x=X2, y=X3, color=val)) + geom_line() + geom_point()
ggplot(mds,aes(x=X4, y=X3, color=val)) + geom_line() + geom_point()
n <- 100
foo <- cbind(rnorm(n), rnorm(n))
require(geometry)
install.packages("geometry")
dim(tr_steps)
length(theta_init)
w <- rgamma(ncol(tr_steps), 1, 1)
w <- w / sum(w)
w
tr_steps_t <- t(tr_steps)
theta_draw <- w %*% tr_steps_t
val <- bfgs_opt_fns$OptimVal(theta_draw)
mask
length(mask)
length(theta_draw)
ncol(tr_steps)
theta_draw <- tr_steps_t %*% w
w <- rgamma(nrow(tr_steps), 1, 1)
w <- w / sum(w)
theta_draw <- tr_steps_t %*% w
val <- bfgs_opt_fns$OptimVal(theta_draw)
n_draws <- 1e3
theta_draws <- matrix(NaN, n_draws, ncol(tr_steps))
n_draws <- 1e3
theta_draws <- matrix(NaN, n_draws, ncol(tr_steps))
val_draws <- rep(NaN, n_draws)
for (ind in 1:n_draws) {
tr_steps_t <- t(tr_steps)
w <- rgamma(nrow(tr_steps), 1, 1)
w <- w / sum(w)
theta_draw <- tr_steps_t %*% w
val <- bfgs_opt_fns$OptimVal(theta_draw)
theta_draws[ind, ] <- theta_draw
val_draws[ind] <- val
}
step_dist <- dist(theta_draws)
draw_dist <- dist(theta_draws)
step_dist <- dist(tr_steps)
draw_mds <- cmdscale(draw_dist, eig=TRUE, k=4)
mds <- data.frame(draw_mds$points)
mds$val <- val_draws
ggplot(mds,aes(x=X1, y=X2, color=val)) + geom_point(, size=2)
ggplot(mds,aes(x=X1, y=X2, color=val)) + geom_point(, size=5, alpha=0.5)
faithfuld
ggplot(mds, aes(X1, X2)) + geom_raster(aes(fill=val), interpolate = TRUE)
nrow(faithfuld)
nrow(mds)
ggplot(mds, aes(X1, X2)) + geom_raster(aes(fill=val), interpolate = TRUE)
head(mds)
ggplot(mds, aes(X1, X2)) + geom_raster(aes(fill=val))
ggplot(mds, aes(x=X1, y=X2)) + geom_raster(aes(fill=val))
ggplot(mds, aes(x=X1, y=X2, color=val)) + geom_point(size=5, alpha=0.5)
draw_mds <- cmdscale(draw_dist, eig=TRUE, k=2)
ggplot(mds, aes(x=X1, y=X2)) + geom_raster(aes(fill=val))
ggplot(faithfuld, aes(waiting, eruptions)) +
geom_raster(aes(fill = density))
faithfuld
faithfuld$waiting
table(faithfuld$waiting)
table(faithfuld$eruptions)
head(mds)
round(1.1231231, 2)
round(1.1231231, 1)
ggplot(mds, aes(x=round(X1, 1), y=round(X2, 1))) + geom_raster(aes(fill=val))
mds$X1_box <- cut(mds$X1, 20)
mds$X1_box
?cut
X1 <- mds$X1
n_grid <- 15
cut(X1, n_grid)
n_grid
quantile(X1, n_grid)
quantiles(X1, n_grid)
?quantile
quantiles(X1, 0)
quantile(X1, 0)
quantile(X1, 1)
max(X1)
min(X1)
x
raw_x <- mds$X1
n_grid <- 15
breaks <- seq(min(raw_x) - 1e-6, max(raw_x) + 1e-6, length.out=n_grid)
intervals <- findInterval(raw_x, breaks)
intervals
grid_x <- breaks[findInterval(raw_x, breaks)]
grid_x
table(grid_x)
breaks <- quantile(raw_x, c(0, (1:(n_grid - 1) / (n_grid - 1)))
breaks <- quantile(raw_x, c(0, (1:(n_grid - 1) / (n_grid - 1))))
breaks
grid_x <- breaks[findInterval(raw_x, breaks)]
table(grid_x)
grid_x[which(raw_x == max(raw_x))]
breaks[n_grid]
breaks
length(breaks)
breaks <- quantile(raw_x, c(0, (1:n_grid) / n_grid))
breaks
grid_x <- breaks[findInterval(raw_x, breaks)]
grid_x
findInterval(raw_x, breaks)
breaks <- quantile(raw_x, c(0, (1:n_grid) / n_grid))
grid_x <- breaks[findInterval(raw_x, breaks)]
table(grid_x)
intervals_x <- findInterval(raw_x, breaks)
intervals_x
table(intervals_x)
intervals_x[intervals_x == n_grid + 1]
intervals_x[intervals_x == n_grid + 1] <- n_grid # Handle the max gracefully
grid_x <- breaks[intervals_x]
table(grid_x)
GridRawData <- function(raw_x, n_grid) {
breaks <- seq(min(raw_x) - 1e-6, max(raw_x) + 1e-6, length.out=n_grid)
breaks <- quantile(raw_x, c(0, (1:n_grid) / n_grid))
intervals_x <- findInterval(raw_x, breaks)
intervals_x[intervals_x == n_grid + 1] <- n_grid # Handle the max gracefully
grid_x <- breaks[intervals_x]
return(grid_x)
}
n_grid <- 15
mds$X1 <- GridRawData(mds$X1, n_grid)
mds <- data.frame(draw_mds$points)
mds$val <- val_draws
GridRawData <- function(raw_x, n_grid) {
breaks <- seq(min(raw_x) - 1e-6, max(raw_x) + 1e-6, length.out=n_grid)
breaks <- quantile(raw_x, c(0, (1:n_grid) / n_grid))
intervals_x <- findInterval(raw_x, breaks)
intervals_x[intervals_x == n_grid + 1] <- n_grid # Handle the max gracefully
grid_x <- breaks[intervals_x]
return(grid_x)
}
n_grid <- 15
mds$X1_grid <- GridRawData(mds$X1, n_grid)
mds$X2_grid <- GridRawData(mds$X2, n_grid)
mds$X3_grid <- GridRawData(mds$X3, n_grid)
mds$X4_grid <- GridRawData(mds$X4, n_grid)
mds$X3
mds$X1_grid <- GridRawData(mds$X1, n_grid)
mds$X2_grid <- GridRawData(mds$X2, n_grid)
ggplot(mds, aes(x=X1_grid, y=X2_grid)) + geom_raster(aes(fill=val))
n_grid <- 6
mds$X1_grid <- GridRawData(mds$X1, n_grid)
mds$X2_grid <- GridRawData(mds$X2, n_grid)
ggplot(mds, aes(x=X1_grid, y=X2_grid)) + geom_raster(aes(fill=val))
step_dist <- dist(tr_steps)
step_mds <- cmdscale(step_dist, eig=TRUE, k=2)
mds_tr <- data.frame(step_mds$points)
mds_tr$val <- trust_result$valpath
ggplot() + geom_raster(aes(x=X1_grid, y=X2_grid, fill=val), data=mds)
ggplot() +
geom_raster(aes(x=X1_grid, y=X2_grid, fill=val), data=mds) +
geom_line(aes(x=X1, y=X2), color="red", lwd=2, data=mds_tr)
ggplot() +
geom_raster(aes(x=X1_grid, y=X2_grid, fill=val), data=mds) +
geom_line(aes(x=X1, y=X2), color="red", lwd=2, data=mds_tr)
